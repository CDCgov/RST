---
title: "02: Understanding and Preparing Your Event Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{02: Understanding and Preparing Your Event Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overview {#sec-overview}

The event and population data are at the core of the `RST` model. They work alongside the adjacency information to generate smoothed estimates. In this vignette, we'll discuss requirements for event and population data and walk through an example with a `data.frame`.

## Requirements {#sec-requirements}

-   Data must be a `list` object with names `Y` and `n` for the event counts and for the population counts, respectively;

-   `Y` and `n` are intended to be entire-population data. While it is possible to use `RST` to analyze survey data or datasets that don't include all members of a population of interest, `RST` does not currently allow for the inclusion of survey weights and thus assumes that each `Y[i, k, t] / n[i, k, t]` is an unbiased estimate of the underlying event rate;

-   `Y` and `n` must contain real numbers. Negative and infinite counts are not allowed, but suppressed data containing `NA`'s is acceptable for the `Y` values. Note, however, that `n` must have all population counts;

-   `Y` and `n` must be a three-dimensional array: the first margin (rows) specifies the time period, the second margin (columns) specifies the region, and the third margin (matrix slices) specifies the groups of interest;

-   Time periods, regions, and groups must be consistent. If your data contains counts for all regions in a specified set of groups for 1979 and 1981, it must also include counts for all regions and all groups for 1980 as well, even if those counts have zero events;

-   Groups of many types are allowed, but all groups must be combined in the third margin. For example, your groups may include just age groups, a mixture of age-sex groups, or even a mix of age-race-sex groups;

-   Finally, `Y` and `n` can optionally have dimension names associated with them. This makes for easy identification of counties, groups, and time periods, and is necessary should you want to age-standardize data using `RST`'s additional functionality.

## Example: CDC WONDER dataset {#sec-example}

To walk through the data setup from a data.frame to the final array list, we will use data generated by CDC WONDER's Underlying Cause of Death Compressed Mortality, ICD-9 database, found at <https://wonder.cdc.gov/cmf-icd9.html>:

```{r eval = FALSE}
maexample
```

Our example dataset contains acute myocardial infarction (ICD-9: 410) mortality and population data in all counties of Massachusetts for men and women aged 35-64 from 1979 to 1981. This dataset also includes some notes in the bottom rows describing the dataset. `maexample` contains several variables:

-   `Notes`: Provides general information about the dataset, starting at row 85;

-   `Year` and `Year.Code` specify the year;

-   `County` and `County.Code` specify the county name and associated FIPS code;

-   `Gender` and `Gender.Code` specify the sex group;

-   `Deaths` contains our mortality counts of interest;

-   `Population` contains our population counts of interest;

-   `Crude.Rate` shows the rates per 100,000 in each year-county-sex group. This column will not be used by us.

The first thing we want to do with our dataset is remove the notes from the bottom rows - while they are useful for getting acquainted with the dataset, they will ultimately mess up our population arrays. Since `Year` does not have information in rows with notes, we can use that to filter our data:

```{r eval = FALSE}
ma_mort = maexample[which(!is.na(maexample$Year)), ]
```

The above code searches for values in `maexample$Year` that aren't `NA` and creates a new dataset containing only those rows. Before we start generating our arrays, let's take stock of how our data is listed out:

```{r eval = FALSE}
head(ma_mort)
```

It's important to take note of how the data cycles through each year-county-sex group so we can appropriately construct our array. In `ma_mort`, the data cycles through each sex group, then each county, and finally each year. This means that when we initially construct our arrays, the dimensions will be number_groups x number_counties x number_years. We know that in our dataset, there are 2 sex groups, 14 counties, and 3 years, so we can use that information to construct `Y` and `n` from `ma_mort$Deaths` and `ma_mort$Population`:

```{r eval = FALSE}
Y = array(ma_mort$Deaths, dim = c(2, 14, 3))
n = array(ma_mort$Population, dim = c(2, 14, 3))
```

Now we have our two arrays set up. However, we have two more things to address before our data is ready to be put into a `list` and into our model: the order of the margins and the dimension names. To fix the order of the margins, we can use the `aperm()` function:

```{r eval = FALSE}
Y = aperm(Y, perm = c(2, 1, 3))
n = aperm(n, perm = c(2, 1, 3))
```

Now, we have our time periods on the rows, our counties on the columns, and our sex groups on the matrix slices. Finally, we can use a `list` in conjunction with the `unique()` function to specify the dimension names for both of these arrays:

```{r eval = FALSE}
dimnames(Y) = dimnames(n) = list(
  county = unique(ma_mort$County.Code),
  group = unique(ma_mort$Gender.Code),
  year = unique(ma_mort$Year.Code)
)
Y
n
```

If you have multiple types of groups, such as race and sex, it can take a little finessing to set up your group data, such as creating a combined race-sex group, but data setup will follow the same principles as above.

Now that our arrays are set up, organized, and properly named, we can finally consolidate them into a `list` to be used with the model:

```{r eval = FALSE}
data = list(Y = Y, n = n)
```

Note that you must specify the names of each array as above, as creating a list with just the objects will not name each element, and the names `Y` and `n` are necessary for `RST` to know how to use the data.

## Closing Thoughts

In this vignette, we used data generated from CDC WONDER to construct our event and population counts, remove unnecessary rows using `filter()`, construct arrays using `array()`, permute those arrays using `aperm()`, and named the arrays using `dimnames()`. Setting up the data for `RST` can seem daunting at first, but with a few quick tricks in R, it can be easy to have your data organized for analysis.
