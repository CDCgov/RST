---
title: "03: Understanding and Preparing Your Adjacency Structure"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{03: Understanding and Preparing Your Adjacency Structure}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overview {#sec-overview}

The adjacency structure is a set of instructions that show the spatial relationship between each region and informs `RSTr` which counties to pull information from when spatially smoothing. In this vignette, we will cover the requirements for the `adjacency` object along with walking through the setup of the adjacency information.

## Requirements

Adjacency information is input as a `list` `adj` where each element `adj[[i]]` is a vector of indices denoting regions that are neighbors of region `i`. Below, we will walk through the construction of both of these types of adjacency information and address common issues that may arise.

## Example: Massachusetts Map Data

For this example, we will continue using Massachusetts data as we did in section 2. Included is an example dataset that contains Massachusetts shapefile information, generated using the `tigris` package:

```{r eval = FALSE}
mamap
```

This dataset contains several variables related to Census information on Massachusetts, but for our purposes we are only interested in two variables:

-   `GEOID` contains the FIPS code for each county. We can use this to associate each county with the counties in our event/population data; and

-   `geometry` describes how to map each region. We can use this to generate our adjacency information.

To begin, let's first arrange `mamap` by `GEOID` to ensure the counties are in the same order as our `maexample` data, then generate some adjacency information using the `spdep` package:

```{r eval = FALSE}
library(tidyverse)
library(spdep)
ma_shp = arrange(mamap, GEOID)
ma_adj = poly2nb(ma_shp)
```

The `poly2nb()` function takes the information in `ma_shp$geometry` and looks for any regions with touching boundaries (i.e., queen contiguity). `ma_adj` is a list that contains the indices of each region that is a neighbor with a given region. Looking at `ma_adj` gives us some more information:

```{r eval = FALSE}
ma_adj
```

`ma_adj` tells that there are 14 regions linked in 38 unique ways. However, it also notes that there are two regions with no links. Regions with no links are problematic for `RSTr` because it has no information with which to spatially smooth, causing the model to crash. Because our data is in this incomplete format, we will have to do some investigation and fixing to get it ready for use.

Let us first look at the dataset to see which counties have no neighbors. `ma_adj` tells us that regions 4 and 10 are our regions with no links, but we can also use the data generated by `poly2nb()` to give us the indices of our no-link counties. `poly2nb` assigns regions without links a 0:

```{r eval = FALSE}
no_neigh = which(sapply(ma_adj, \(x) all(x == 0)))
```

Using the `sapply()` function, we can return a `logical` vector that checks each element of `ma_adj` for zeros. Then, with `which()`, we specify the indices where our `logical` is true. We can now investigate `ma_shp` for which counties have no neighbors:

```{r eval = FALSE}
ma_shp[no_neigh, ]
```

According to this, our two no-link counties are Dukes and Nantucket (FIPS 25007 and 25019, respectively). Let's check out a ggplot of our data to further investigate:

```{r eval = FALSE}
ggplot(mamap) +
  geom_sf(aes(fill = NAME)) +
  geom_sf_label(aes(label = NAME))
```

Here, we've generated a map colored by region and labeled with the name of each county. We can see Dukes and Nantucket in the southeast corner, and if you zoom in, you can see that these two counties aren't touching any other counties. Upon closer inspection, Barnstable County seems like a good contender for a neighbor to both Dukes and Nantucket County, and Dukes and Nantucket County are also close enough to be neighbors to each other. To rectify this, we can manually make some changes to our adjacency information. Let's first get a feel for which counties are associated with which indices:

```{r eval = FALSE}
county_key = seq_along(ma_shp$NAME)
names(county_key) = ma_shp$NAME
county_key
```

We can see that Barnstable has an index of 1, Dukes has an index of 4, and Nantucket has an index of 10. Now, let's manually add neighbors as necessary to our adjacency structures:

```{r eval = FALSE}
ma_adj[[1]]  = as.integer(c(ma_adj[[1]], 4, 10)) # Add neighbors to Barnstable
ma_adj[[4]]  = as.integer(c(1, 10)) # Replace 0 with neighbors for Dukes
ma_adj[[10]] = as.integer(c(1, 4)) # Replace 0 with neighbors for Nantucket
```

Here, we append the neighbors of Barnstable to the pre-existing neighbors of Barnstable, but overwrite the 0's for Dukes and Nantucket and cast them all as integer vectors. Now if we look at `ma_adj`, the message about no-link regions is gone.

One last feature we can add to these adjacencies are dimension names. This isn't necessary, but it can be useful to associate regions in our `data` object with regions inside of our adjacency structure:

```{r eval = FALSE}
names(ma_adj) = ma_shp$GEOID
for (i in seq_along(ma_adj)) {
  names(ma_adj[[i]]) = ma_shp$GEOID[ma_adj[[i]]]
}
```

The above code assigns each FIPS code to each element of `ma_adj`, then assigns the indices inside of each element of `ma_adj` to its associated FIPS code.

Note that if you run a model in `RSTr` and load in the adjacency information saved in your model's `spatial_data.Rds` file, the indices will have changed. This is because `ma_adj` is only used within Rcpp, which uses a 0-indexing system as opposed to the 1-indexing system used by R. When inputting data into `initialize_model()`, only use a 1-indexed adjacency structure.

Finally, even though we connected the two island counties to the mainland counties of MA, as long as each region has at least one neighbor, it is usable within `RSTr`. This means that, theoretically, we could have made just Dukes and Nantucket neighbors of each other, creating two separate "islands" of regions with no related neighbors, but every region on both "islands" still has at least one neighbor.

## Closing Thoughts

In this vignette, we used the `poly2nb()` function inside of the `spdep` package to generate our adjacency structure and demonstrated the two types of appropriate adjacency objects: a list of indices or a binary matrix. We then fixed issues with counties without neighbors and applied a naming scheme to the adjacency information consistent with the `data` object created in section 2. From here, the `RSTr` model is ready to be run with our `data` and `adjacency` information!
