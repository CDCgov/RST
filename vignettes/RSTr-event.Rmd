---
title: "02: Understanding and Preparing Your Event Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{02: Understanding and Preparing Your Event Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overview {#sec-overview}

The event and population data are at the core of the `RSTr` model. They work alongside the adjacency information to generate smoothed estimates. In this vignette, we'll discuss requirements for event and population data and walk through an example with a `data.frame`.

## Requirements {#sec-requirements}

-   Data must be a `list` object with names `Y` and `n` for the event counts and for the population counts, respectively;

-   `Y` and `n` are intended to be entire-population data. While it is possible to use `RSTr` to analyze survey data or datasets that don't include all members of a population of interest, `RSTr` does not currently allow for the inclusion of survey weights and thus assumes that each `Y / n` is an unbiased estimate of the underlying event rate;

-   `Y` and `n` must contain real numbers. Negative and infinite counts are not allowed, but suppressed data containing `NA`'s is acceptable for the `Y` values. Note, however, that `n` must have all population counts;

-   For the MSTCAR model, `Y` and `n` must be a three-dimensional array: the first margin (rows) specifies the region, the second margin (columns) specifies the groups of interest, and the third margin (matrix slices) specifies the time period. Other models will follow this same order of margins: for example, data for the MCAR model will be a two-dimensional array (matrix) with regions along the rows and groups along the columns, and a USTCAR model will have regions along the rows and time periods along the columns. Data for the UCAR model can simply be a vector;

-   Time periods, regions, and groups must be consistent. If your data contains counts for all regions in a specified set of groups for 1979 and 1981, for example, it must also include counts for all regions and all groups for 1980 as well, even if those counts have zero events;

-   Groups of many types are allowed, but all groups must be combined into the appropriate margin (3 for MSTCAR, 2 for MCAR/USTCAR). For example, your groups may include just age groups, a mixture of age-sex groups, or even a mix of age-race-sex groups;

-   Finally, `Y` and `n` can optionally have dimension names associated with them. This makes for easy identification of counties, groups, and time periods, and is necessary should you want to age-standardize data using `RSTr`'s additional functionality.

## Example: CDC WONDER dataset {#sec-example}

To walk through the data setup from a data.frame to the final array list, we will use data generated by CDC WONDER's Underlying Cause of Death Compressed Mortality, ICD-9 database, found at <https://wonder.cdc.gov/cmf-icd9.html>:

```{r eval = FALSE}
maexample
```

Our example dataset contains acute myocardial infarction (ICD-9: 410) mortality and population data in all counties of Massachusetts for men and women aged 35-64 from 1979 to 1981. This dataset also includes some notes in the bottom rows describing the dataset. `maexample` contains several variables:

-   `Notes`: Provides general information about the dataset, starting at row 85;

-   `Year` and `Year.Code` specify the year;

-   `County` and `County.Code` specify the county name and associated FIPS code;

-   `Gender` and `Gender.Code` specify the sex group;

-   `Deaths` contains our mortality counts of interest;

-   `Population` contains our population counts of interest;

-   `Crude.Rate` shows the rates per 100,000 in each year-county-sex group. This column will not be used by us.

The first thing we want to do with our dataset is remove the notes from the bottom rows - while they are useful for getting acquainted with the dataset, they will ultimately mess up our population arrays. Since `Year` does not have information in rows with notes, we can use that to filter our data:

```{r eval = FALSE}
ma_mort = maexample[which(!is.na(maexample$Year)), ]
```

The above code searches for values in `maexample$Year` that aren't `NA` and creates a new dataset containing only those rows. Before we start generating our arrays, let's take stock of how our data is listed out:

```{r eval = FALSE}
head(ma_mort)
```

It's important to take note of how the data cycles through each year-county-sex group so we can appropriately construct our array. In `ma_mort`, the data cycles through each sex group, then each county, and finally each year. This means that when we initially construct our arrays, the dimensions will be num_group x num_county x num_year. We know that in our dataset, there are 2 sex groups, 14 counties, and 3 years, so we can use that information to construct `Y` and `n` from `ma_mort$Deaths` and `ma_mort$Population`:

```{r eval = FALSE}
Y = array(ma_mort$Deaths, dim = c(2, 14, 3))
n = array(ma_mort$Population, dim = c(2, 14, 3))
```

Now we have our two arrays set up. However, we have two more things to address before our data is ready to be put into a `list` and into our model: the order of the margins and the dimension names. To fix the order of the margins, we can use the `aperm()` function, which helps to reorder the margins of a dataset as desired:

```{r eval = FALSE}
Y = aperm(Y, perm = c(2, 1, 3))
n = aperm(n, perm = c(2, 1, 3))
```

Now, we have our time periods on the rows, our counties on the columns, and our sex groups on the matrix slices. Finally, we can use a `list` in conjunction with the `unique()` function to specify the dimension names for both of these arrays:

```{r eval = FALSE}
dimnames(Y) = dimnames(n) = list(
  county = unique(ma_mort$County.Code),
  group = unique(ma_mort$Gender.Code),
  year = unique(ma_mort$Year.Code)
)
Y
n
```

If you have multiple types of groups, such as race and sex, it can take a little finessing to set up your group data, such as creating a combined race-sex group, but data setup will follow the same principles as above.

Now that our arrays are set up, organized, and properly named, we can finally consolidate them into a `list` to be used with the model:

```{r eval = FALSE}
data = list(Y = Y, n = n)
```

Note that you must specify the names of each array as above, as creating a list with just the objects will not name each element, and the names `Y` and `n` are necessary for `RSTr` to know how to use the data.

## Data setup for other models

The above dataset is prepared specifically for an MSTCAR model. But what if we only want to run an MCAR or even a UCAR model? We can filter the original dataset and follow a similar procedure to prepare our data for the MCAR model:

```{r eval = FALSE}
ma_mort_mcar = maexample[which(!is.na(maexample$Year)), ]
ma_mort_mcar = ma_mort_mcar[ma_mort_mcar$Year == 1979, ] # filter dataset to only show 1979 data
Y = matrix(ma_mort_mcar$Deaths, nrow = 2, ncol = 14) # data goes by sex group first, then county
n = matrix(ma_mort_mcar$Population, nrow = 2, ncol = 14)
Y = t(Y) # transpose so that regions are on rows, groups are on columns
n = t(n)
dimnames(Y) = dimnames(n) = list(
  county = unique(ma_mort_mcar$County.Code),
  group = unique(ma_mort_mcar$Gender.Code)
)
data = list(Y = Y, n = n)
```

The USTCAR model will follow a similar process to the MCAR model, but with a single group and multiple time periods.

For the UCAR model, setup is even easier:

```{r eval = FALSE}
ma_mort_ucar = maexample[which(!is.na(maexample$Year)), ]
ma_mort_ucar = ma_mort_ucar[ma_mort_ucar$Year == 1979 & ma_mort_ucar$Gender == "Male", ] # filter dataset to only show 1979 data for men
Y = ma_mort_ucar$Deaths
n = ma_mort_ucar$Population
names(Y) = names(n) = unique(ma_mort_ucar$County.Code)
data = list(Y = Y, n = n)
```

## Closing Thoughts

In this vignette, we used data generated from CDC WONDER to construct our event and population counts, remove unnecessary rows using `filter()`, construct arrays using `array()`, permute those arrays using `aperm()`, and named the arrays using `dimnames()`. Setting up the data for `RSTr` can seem daunting at first, but with a few quick tricks in R, it can be easy to have your data organized for analysis.
